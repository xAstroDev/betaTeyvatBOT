import _ from 'lodash';
import React from 'react';
import { connect } from 'react-redux';

import { AttributionControl, Map, TileLayer, ZoomControl } from 'react-leaflet';
import ReactLeafletEditable from 'react-leaflet-editable';

import { editorMarkerHighlight, lineProperties, lineTextProperties } from './LayerConstants';
import { useImageExtension } from '../Image';

import { setPositionAndZoom } from '../../redux/ducks/ui';
import { appendElement, setElementProperty } from '../../redux/ducks/editor';

import {
  DEFAULT_ZOOM,
  MAP_BOUNDS,
  MAP_CENTER,
  MAXIMUM_ZOOM,
  MINIMUM_ZOOM,
  TILE_URL,
} from '../preferences/DefaultPreferences';
import EditorControls from './EditorControls';

// A link back to the main repository.
const ATTRIBUTION =
  "<a href='https://github.com/GenshinMap/genshinmap.github.io' rel='noreferrer' target='_blank'><span class='nf nf-fa-github' style='margin-right: 0.5em;'></span>Directions and Feedback</a>";

/**
 * A wrapper which handles editing events.
 * Much of the complexity here comes from the fact we aren't editing the map,
 * we are editing a GeoJSON representation of it.
 *
 * Thus, each element creation must be 'cancelled',
 * then replaced with addition to the GeoJSON data.
 */
// Note: The dispatchers generated by mapDispatchToProps
// shadow their associated action generators.
/* eslint-disable no-shadow */
const _MapEditor = ({
  mapRef,
  editRef,
  children,

  mapPosition,

  appendMarker,
  appendRoute,
  moveMarker,
  moveRoute,
  setPositionAndZoom,
}) => {
  // A separate state must be used because the type of currentEditable can't be determined
  // just by looking at it.
  const [editorState, setEditorState] = React.useState('none');
  const [currentEditable, setCurrentEditable] = React.useState(null);

  const startEditorMarker = () => {
    setEditorState('createMarker');
    const editable = editRef.current.startMarker(null, {
      icon: editorMarkerHighlight,
    });
    setCurrentEditable(editable);
  };

  const startEditorRoute = () => {
    setEditorState('createRoute');
    const editable = editRef.current.startPolyline(null, lineProperties);
    editable.setText('  â–º  ', lineTextProperties);
    setCurrentEditable(editable);
  };

  const placeMarker = (editable) => {
    const { _latlng: latlng } = editable;

    // Note this is not reversed because it corresponds to direct map coordinates.
    const latlngFormatted = [latlng?.lat, latlng?.lng];

    const newMarker = {
      geometry: { type: 'Point', coordinates: latlngFormatted },
      type: 'Feature',
      properties: { popupTitle: { en: '' }, popupContent: { en: '' }, popupMedia: '' },
    };

    appendMarker(newMarker);
    setEditorState('none');
    setCurrentEditable(null);
  };

  const placeRoute = (editable) => {
    const { _latlngs: latlngs } = editable;
    // Note this is not reversed because it corresponds to direct map coordinates.
    const latlngsFormatted = latlngs.map((latlng) => [latlng?.lat, latlng?.lng]);

    const newRoute = {
      geometry: { type: 'LineString', coordinates: latlngsFormatted },
      type: 'Feature',
      properties: { popupTitle: '', popupContent: '', popupMedia: '' },
    };
    appendRoute(newRoute);
    setEditorState('none');
    setCurrentEditable(null);
  };

  const onDragStart = (event) => {
    // Called when starting to drag a marker.

    const isMarker = event.layer.feature.geometry.type === 'Point';
    // const isRouteVertex = event.layer.feature.geometry.type === "LineMarker";

    if (isMarker) {
      setCurrentEditable(event.layer);
      setEditorState('dragMarker');
      // return;
    }
  };

  const onDragEnd = (event) => {
    // If the current mode is 'dragMarker', call our override function,
    // and cancel the event that would occur.

    if (editorState === 'dragMarker') {
      const marker = event.layer.feature;

      // eslint-disable-next-line no-underscore-dangle
      const { _latlng: latlng } = event.layer;

      const newCoords = [latlng.lat, latlng.lng];

      moveMarker(marker, newCoords);
      setEditorState('none');
      setCurrentEditable(null);
    }
  };

  const onVertexMarkerDragStart = (event) => {
    const isRoute = event.layer.feature.geometry.type === 'LineString';
    // const isRouteVertex = event.layer.feature.geometry.type === "LineMarker";
    if (isRoute) {
      setCurrentEditable(event.layer);
      setEditorState('dragRoute');
      // return;
    }
  };

  const onVertexMarkerDragEnd = (event) => {
    // If the current mode is 'dragMarker', call our override function,
    // and cancel the event that would occur.

    if (editorState === 'dragRoute') {
      const route = event.layer.feature;
      const newRouteLatLngs = event.vertex.latlngs.map((vertex) => [vertex.lat, vertex.lng]);

      moveRoute(route, newRouteLatLngs);
      setEditorState('none');
      setCurrentEditable(null);
    }
  };

  const onDrawingCommit = (event, map) => {
    if (editorState === 'createRoute') {
      map.removeLayer(currentEditable);
      placeRoute(currentEditable);
      return;
    }

    if (editorState === 'createMarker') {
      map.removeLayer(currentEditable);
      placeMarker(currentEditable);
      // return;
    }
  };

  /**
   * Every time the user drags or zooms to a position on the map,
   * update the state.
   */
  const onChangeMapPos = () => {
    if (mapRef?.current?.leafletElement == null) return;

    setPositionAndZoom(
      mapRef.current.leafletElement.getCenter(),
      mapRef.current.leafletElement.getZoom()
    );
  };

  React.useEffect(() => {
    if (mapRef?.current?.leafletElement == null) return;

    if (
      mapPosition.latlng !== mapRef.current.leafletElement.getCenter() ||
      mapPosition.zoom !== mapRef.current.leafletElement.getZoom()
    ) {
      mapRef.current.leafletElement.setView(
        [mapPosition.latlng.lat, mapPosition.latlng.lng],
        mapPosition.zoom,
        { animate: true, duration: 0.25, easeLinearity: 0.25, noMoveStart: false }
      );
    }
  }, [mapPosition]);

  // Check for WebP support.
  const ext = useImageExtension(true);

  // Wait until we get confirmation of WebP support.
  if (ext == null) return null;

  const tileUrl = TILE_URL.replace('{ext}', ext);

  return (
    <ReactLeafletEditable
      ref={editRef}
      onDragStart={onDragStart}
      onDragEnd={onDragEnd}
      onVertexMarkerDragStart={onVertexMarkerDragStart}
      onVertexMarkerDragEnd={onVertexMarkerDragEnd}
      onDrawingCommit={onDrawingCommit}
    >
      <Map
        ref={mapRef}
        ondragend={onChangeMapPos}
        onzoomend={onChangeMapPos}
        maxBounds={MAP_BOUNDS}
        center={MAP_CENTER}
        zoom={DEFAULT_ZOOM}
        zoomDelta={0.5}
        editable
        zoomSnap={0.5}
        maxZoom={MAXIMUM_ZOOM}
        minZoom={MINIMUM_ZOOM}
        attributionControl={false} // Override the Leaflet attribution with our own AttributionControl.
        zoomControl={false}
      >
        {/* Controls the actual map image. */}
        <TileLayer url={tileUrl} noWrap bounds={MAP_BOUNDS} errorTileUrl={`tiles/blank.${ext}`} />
        {/* Controls the attribution link in the bottom left corner. */}
        <AttributionControl prefix={ATTRIBUTION} position="bottomleft" />
        {/* Controls the zoom buttons in the top left corner. */}
        <ZoomControl zoomInTitle="+" zoomOutTitle="-" />
        <EditorControls startEditorMarker={startEditorMarker} startEditorRoute={startEditorRoute} />

        {children}
      </Map>
    </ReactLeafletEditable>
  );
};

const mapStateToProps = (state) => ({
  mapPosition: state.position,
});
const mapDispatchToProps = (dispatch) => ({
  setPositionAndZoom: (position, zoom) => dispatch(setPositionAndZoom(position, zoom)),
  appendMarker: (data) => dispatch(appendElement(data)),
  appendRoute: (data) => dispatch(appendElement(data)),
  moveMarker: (marker, newCoords) =>
    dispatch(setElementProperty(marker, 'geometry.coordinates', newCoords)),
  moveRoute: (route, newCoordsList) =>
    dispatch(setElementProperty(route, 'geometry.coordinates', newCoordsList)),
});
const MapEditorConnected = connect(mapStateToProps, mapDispatchToProps)(_MapEditor);
const MapEditor = React.forwardRef((props, ref) => <MapEditorConnected {...props} editRef={ref} />);

export default MapEditor;
